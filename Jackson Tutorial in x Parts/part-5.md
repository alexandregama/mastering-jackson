## 5 - Serializing Getter Methods to JSON

Let's change the **Tutorial** class and rename the getter method **getLanguage()** to **getUsedLanguage()** to just see what happens:

```java
public class Tutorial {

	public String getUsedLanguage() {
		return language;
	}

}
```

It's time to generate the JSON object with Jackson again:

```java
@Test
public void shouldSerializeGetterMethodsByDefault() throws Exception {
	Tutorial tutorial = new Tutorial(1L, "CDI - How to use Decorators", "Java");

	ObjectWriter prettyPrinter = new ObjectMapper().writerWithDefaultPrettyPrinter();
	String prettyJson = prettyPrinter.writeValueAsString(tutorial);

	System.out.println(prettyJson);
}
```

The output will be:

```json
{
  "id" : 1,
  "title" : "CDI - How to use Decorators",
  "usedLanguage" : "Java"
}
```

As you can see, **Jackson uses the getter method** to serialize the object into a JSON! Notice that the JSON attribute was named as **usedLanguage**.

We can change this JSON attribute name by configuring a **custom name** with the ```@JsonGetter``` annotation:

```java
@JsonGetter(value = "getAwesomeUsedLanguage")
public String getUsedLanguage() {
	return language;
}
```

If you run the code, you'll have the new attribute name generated by Jackson:

```json
{
  "id" : 1,
  "title" : "CDI - How to use Decorators",
  "getAwesomeUsedLanguage" : "Java"
}
```

#### Removing the Getter method to serialize the JSON Object

if we **remove** the getter method? How does Jackson generate the JSON object if it is used to parse the Java object into a JSON?

If you run the code without the **getLanguage()** method you'll have the following result:

```json
{
  "id" : 1,
  "title" : "CDI - How to use Decorators"
}
```

As you can see, the JSON in the output **will not have** the property in the JSON object because, again, Jackson uses **getter** methods to serialize objects to JSON.

But can we change this behavior? Of course! Are you curious about how? Let's see the next Post!
